# -*- coding: utf-8 -*-
"""name_indexing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R-PGYO6NCreSqsMt4wOvcctk0_Jae69s
"""

def normalize_hebrew_name(name):
    """
    Create a normalized version of the Hebrew name by:
    1. Removing א and ע characters
    2. Sorting name parts right-to-left
    Returns normalized version for comparison
    """
    # Remove nikud if exists (Hebrew vowel points)
    name = ''.join(char for char in name if ord(char) < 0x0591 or ord(char) > 0x05C7)

    # Create normalized version for comparison (remove א and ע)
    normalized = name.replace('א', '').replace('ע', '')

    # Split into parts and sort (Hebrew names should sort right-to-left)
    parts = normalized.split()
    parts.sort(reverse=True)  # reverse=True for Hebrew right-to-left sorting

    return ' '.join(parts)

def are_names_similar(norm1, norm2, max_distance=2):
    """
    Check if two normalized Hebrew names are similar based on Levenshtein distance
    """
    return distance(norm1, norm2) <= max_distance

def create_name_indices(df, name_column):
    """
    Create indices for similar Hebrew names in the DataFrame.
    Returns a new DataFrame with additional 'normalized_name' and 'name_index' columns.
    """
    # Create a copy of the DataFrame
    result_df = df.copy()

    # Add normalized names column
    result_df['normalized_name'] = result_df[name_column].apply(normalize_hebrew_name)

    # Initialize name mapping dictionary and current index
    name_indices = {}
    current_index = 0

    # Process each name
    for idx, row in result_df.iterrows():
        normalized_name = row['normalized_name']

        # Check if this normalized name is similar to any existing indexed name
        found_match = False
        for existing_norm, existing_index in name_indices.items():
            if are_names_similar(normalized_name, existing_norm):
                result_df.at[idx, 'name_index'] = existing_index
                found_match = True
                break

        # If no match found, create new index
        if not found_match:
            name_indices[normalized_name] = current_index
            result_df.at[idx, 'name_index'] = current_index
            current_index += 1

    return result_df

result = create_name_indices(df, 'person\'s name')
result.head()